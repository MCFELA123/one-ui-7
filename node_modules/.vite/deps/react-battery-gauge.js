import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/react-battery-gauge/dist/react-battery-gauge.esm.js
var import_react = __toESM(require_react());
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var CANVAS_WIDTH = 100;
var CANVAS_HEIGHT = 52;
var BATTERY_ASPECT_RATIO = CANVAS_HEIGHT / CANVAS_WIDTH;
var BATTERY_BODY = "batteryBody";
var BATTERY_CAP = "batteryCap";
var BATTERY_METER = "batteryMeter";
var READING_TEXT = "readingText";
var CHARGING_FLASH = "chargingFlash";
var CLIP_METER = "clip_level_meter";
var CLIP_METER_FILLED = "clip_level_meter_filled";
var CLIP_METER_EMPTY = "clip_level_meter_empty";
var CLIP_CAP = "battery_cap_clip";
var defaultState = {
  canvasWidth: CANVAS_WIDTH,
  canvasHeight: CANVAS_WIDTH * BATTERY_ASPECT_RATIO,
  aspectRatio: BATTERY_ASPECT_RATIO,
  padding: 0,
  value: 50,
  chargingStartValue: 1,
  maxValue: 100,
  clipPathHash: "",
  orientation: "horizontal",
  animated: false,
  charging: false,
  customization: {
    batteryBody: {
      strokeWidth: 4,
      cornerRadius: 6,
      fill: "none",
      strokeColor: "#111"
    },
    batteryCap: {
      fill: "none",
      strokeWidth: 4,
      strokeColor: "#111",
      cornerRadius: 2,
      capToBodyRatio: 0.4
    },
    batteryMeter: {
      fill: "green",
      lowBatteryValue: 15,
      lowBatteryFill: "red",
      outerGap: 1,
      noOfCells: 1,
      interCellsGap: 1
    },
    readingText: {
      lightContrastColor: "#111",
      darkContrastColor: "#fff",
      lowBatteryColor: "red",
      fontFamily: "Helvetica",
      fontSize: 14,
      showPercentage: true
    },
    chargingFlash: {
      scale: void 0,
      fill: "orange",
      animated: true,
      animationDuration: 1e3
    }
  }
};
var Context = (0, import_react.createContext)(defaultState);
function useGaugeContext() {
  return (0, import_react.useContext)(Context);
}
var useBatteryDimensions = function useBatteryDimensions2(batteryCapRatio) {
  var _useGaugeContext = useGaugeContext(), canvasHeight = _useGaugeContext.canvasHeight, canvasWidth = _useGaugeContext.canvasWidth, padding = _useGaugeContext.padding;
  var objectHeight = canvasHeight - 2 * padding;
  var capHeight = objectHeight * batteryCapRatio;
  var capWidth = capHeight / 2;
  return {
    bodyWidth: canvasWidth - capWidth - 2 * padding,
    bodyHeight: canvasHeight - 2 * padding,
    capWidth,
    capHeight
  };
};
var Battery = function Battery2() {
  var _useGaugeContext = useGaugeContext(), canvasWidth = _useGaugeContext.canvasWidth, canvasHeight = _useGaugeContext.canvasHeight, padding = _useGaugeContext.padding, customization = _useGaugeContext.customization, clipPathHash = _useGaugeContext.clipPathHash;
  var _customization$BATTER = customization[BATTERY_BODY], bodyStrokeColor = _customization$BATTER.strokeColor, bodyStrokeWidth = _customization$BATTER.strokeWidth, bodyFill = _customization$BATTER.fill, bodyCornerRadius = _customization$BATTER.cornerRadius;
  var _customization$BATTER2 = customization[BATTERY_CAP], capStrokeColor = _customization$BATTER2.strokeColor, capStrokeWidth = _customization$BATTER2.strokeWidth, capFill = _customization$BATTER2.fill, capCornerRadius = _customization$BATTER2.cornerRadius, capToBodyRatio = _customization$BATTER2.capToBodyRatio;
  var _useBatteryDimensions = useBatteryDimensions(capToBodyRatio), bodyWidth = _useBatteryDimensions.bodyWidth, bodyHeight = _useBatteryDimensions.bodyHeight, capWidth = _useBatteryDimensions.capWidth, capHeight = _useBatteryDimensions.capHeight;
  return import_react.default.createElement("g", null, import_react.default.createElement("defs", null, import_react.default.createElement("clipPath", {
    id: CLIP_CAP + clipPathHash
  }, import_react.default.createElement("rect", {
    x: canvasWidth - padding - capWidth,
    y: (canvasHeight - capHeight - capStrokeWidth) / 2,
    width: capWidth,
    height: capHeight + capStrokeWidth,
    strokeWidth: capStrokeWidth
  }))), import_react.default.createElement("rect", {
    className: BATTERY_BODY,
    x: padding,
    y: padding,
    rx: bodyCornerRadius,
    ry: bodyCornerRadius,
    width: bodyWidth,
    height: bodyHeight,
    strokeWidth: bodyStrokeWidth,
    fill: bodyFill,
    stroke: bodyStrokeColor
  }), import_react.default.createElement("rect", {
    clipPath: "url(#" + (CLIP_CAP + clipPathHash) + ")",
    className: BATTERY_CAP,
    x: canvasWidth - padding - capWidth - capCornerRadius,
    y: (canvasHeight - capHeight) / 2,
    rx: capCornerRadius,
    ry: capCornerRadius,
    width: capWidth,
    height: capHeight,
    strokeWidth: capStrokeWidth,
    fill: capFill,
    stroke: capStrokeColor
  }));
};
var CanvasProvider = function CanvasProvider2(_ref) {
  var children = _ref.children, value = _ref.value;
  return import_react.default.createElement(Context.Provider, {
    value
  }, children);
};
var _excluded = ["children", "canvasWidth", "canvasHeight", "padding", "value", "chargingStartValue", "maxValue", "orientation", "customization", "clipPathHash"];
var Canvas = function Canvas2(props) {
  var children = props.children, canvasWidth = props.canvasWidth, canvasHeight = props.canvasHeight, padding = props.padding, value = props.value, chargingStartValue = props.chargingStartValue, maxValue = props.maxValue, orientation = props.orientation, customization = props.customization, clipPathHash = props.clipPathHash, otherSvgProps = _objectWithoutPropertiesLoose(props, _excluded);
  return import_react.default.createElement(CanvasProvider, {
    value: {
      canvasWidth,
      canvasHeight,
      padding,
      value,
      chargingStartValue,
      maxValue,
      orientation,
      customization,
      clipPathHash
    }
  }, import_react.default.createElement("svg", Object.assign({
    viewBox: "0 0 " + canvasWidth + " " + canvasHeight
  }, otherSvgProps), children));
};
var useLevelDimensions = function useLevelDimensions2() {
  var _useGaugeContext = useGaugeContext(), padding = _useGaugeContext.padding, customization = _useGaugeContext.customization;
  var strokeWidth = customization[BATTERY_BODY].strokeWidth;
  var capToBodyRatio = customization[BATTERY_CAP].capToBodyRatio;
  var outerGap = customization[BATTERY_METER].outerGap;
  var _useBatteryDimensions = useBatteryDimensions(capToBodyRatio), bodyWidth = _useBatteryDimensions.bodyWidth, bodyHeight = _useBatteryDimensions.bodyHeight;
  return (0, import_react.useMemo)(function() {
    var innerBodyWidth = bodyWidth - strokeWidth;
    var innerBodyHeight = bodyHeight - strokeWidth;
    return {
      x: padding + strokeWidth / 2 + outerGap,
      y: padding + strokeWidth / 2 + outerGap,
      width: innerBodyWidth - 2 * outerGap,
      height: innerBodyHeight - 2 * outerGap
    };
  }, [bodyWidth, bodyHeight, outerGap, padding, strokeWidth]);
};
function getValueInPercentage(value, maxValue) {
  return Math.round(value / maxValue * 100);
}
function checkLowBattery(value, lowBatteryValue) {
  return value < lowBatteryValue;
}
function getVisibleCellsCount(value, maxValue, noOfCells) {
  return Math.floor(Math.abs(value / maxValue) * noOfCells);
}
var timing = function timing2(progress, easing) {
  if (easing === "linear") {
    return progress;
  }
  return progress;
};
var BatteryLevel = function BatteryLevel2() {
  var _useGaugeContext = useGaugeContext(), value = _useGaugeContext.value, maxValue = _useGaugeContext.maxValue, customization = _useGaugeContext.customization, clipPathHash = _useGaugeContext.clipPathHash;
  var _useLevelDimensions = useLevelDimensions(), x = _useLevelDimensions.x, y = _useLevelDimensions.y, width = _useLevelDimensions.width, height = _useLevelDimensions.height;
  var _customization$BATTER = customization[BATTERY_METER], fill = _customization$BATTER.fill, lowBatteryFill = _customization$BATTER.lowBatteryFill, gradFill = _customization$BATTER.gradFill, lowBatteryValue = _customization$BATTER.lowBatteryValue, outerGap = _customization$BATTER.outerGap, noOfCells = _customization$BATTER.noOfCells, interCellsGap = _customization$BATTER.interCellsGap;
  var _customization$BATTER2 = customization[BATTERY_BODY], bodyStrokeWidth = _customization$BATTER2.strokeWidth, bodyCornerRadius = _customization$BATTER2.cornerRadius;
  var cellList = (0, import_react.useMemo)(function() {
    var noOfVisibleCells = getVisibleCellsCount(value, maxValue, noOfCells);
    if (noOfVisibleCells === 0 && value > 0) {
      return ["cell"];
    }
    return new Array(noOfVisibleCells).fill("cell");
  }, [value, maxValue, noOfCells]);
  return import_react.default.createElement("g", null, import_react.default.createElement("defs", null, import_react.default.createElement("clipPath", {
    id: CLIP_METER + clipPathHash
  }, import_react.default.createElement("rect", {
    x,
    y,
    rx: bodyCornerRadius - bodyStrokeWidth / 2 - outerGap,
    ry: bodyCornerRadius - bodyStrokeWidth / 2 - outerGap,
    width,
    height
  })), noOfCells < 2 && gradFill && import_react.default.createElement("linearGradient", {
    id: "levelGradient" + clipPathHash
  }, gradFill.map(function(item) {
    return import_react.default.createElement("stop", {
      key: item.color,
      offset: item.offset + "%",
      stopColor: item.color
    });
  }))), noOfCells === 1 && import_react.default.createElement("g", null, gradFill ? import_react.default.createElement("rect", {
    className: BATTERY_METER,
    clipPath: "url(#" + (CLIP_METER_FILLED + clipPathHash) + ")",
    x,
    y,
    width,
    height,
    fill: "url(#levelGradient" + clipPathHash + ")"
  }) : import_react.default.createElement("rect", {
    className: BATTERY_METER,
    clipPath: "url(#" + (CLIP_METER + clipPathHash) + ")",
    x,
    y,
    width: width * value / maxValue,
    height,
    fill: checkLowBattery(value, lowBatteryValue) ? lowBatteryFill : fill
  })), import_react.default.createElement("g", null, noOfCells > 1 && cellList.map(function(_item, index) {
    return import_react.default.createElement("rect", {
      key: index,
      className: BATTERY_METER,
      clipPath: "url(#" + (CLIP_METER + clipPathHash) + ")",
      x: x + (width + interCellsGap) / noOfCells * index,
      y,
      width: width / noOfCells - interCellsGap,
      height,
      fill: checkLowBattery(value, lowBatteryValue) ? lowBatteryFill : fill
    });
  })));
};
var _excluded$1 = ["fontFamily", "darkContrastColor", "lightContrastColor", "lowBatteryColor", "showPercentage", "fontSize"];
var ReadingText = function ReadingText2(props) {
  var formatValue = props.formatValue;
  var _useGaugeContext = useGaugeContext(), value = _useGaugeContext.value, maxValue = _useGaugeContext.maxValue, orientation = _useGaugeContext.orientation, customization = _useGaugeContext.customization, clipPathHash = _useGaugeContext.clipPathHash;
  var _useLevelDimensions = useLevelDimensions(), x = _useLevelDimensions.x, y = _useLevelDimensions.y, width = _useLevelDimensions.width, height = _useLevelDimensions.height;
  var _customization$READIN = customization[READING_TEXT], fontFamily = _customization$READIN.fontFamily, darkContrastColor = _customization$READIN.darkContrastColor, lightContrastColor = _customization$READIN.lightContrastColor, lowBatteryColor = _customization$READIN.lowBatteryColor, showPercentage = _customization$READIN.showPercentage, fontSize = _customization$READIN.fontSize, otherTextProps = _objectWithoutPropertiesLoose(_customization$READIN, _excluded$1);
  var _customization$BATTER = customization[BATTERY_METER], lowBatteryValue = _customization$BATTER.lowBatteryValue, noOfCells = _customization$BATTER.noOfCells, interCellsGap = _customization$BATTER.interCellsGap;
  var percentageSign = showPercentage ? "%" : "";
  var valueRatio = value / maxValue;
  var isCellTypeBattery = noOfCells > 1;
  var noOfVisibleCells = getVisibleCellsCount(value, maxValue, noOfCells);
  var noOfInvisibleCells = noOfCells - noOfVisibleCells;
  var widthPerCell = width / noOfCells;
  var readingValue = getValueInPercentage(value, maxValue);
  var renderTextElement = function renderTextElement2(contrastColor, clipPathId) {
    return import_react.default.createElement("text", Object.assign({
      className: READING_TEXT,
      x: x + width / 2,
      y: y + height / 2,
      dominantBaseline: "middle",
      textAnchor: "middle",
      clipPath: "url(#" + clipPathId + ")",
      fill: checkLowBattery(value, lowBatteryValue) ? lowBatteryColor : contrastColor,
      fontFamily,
      fontWeight: "bold",
      fontSize,
      writingMode: orientation === "vertical" ? "tb" : "lr"
    }, otherTextProps), formatValue(readingValue) + percentageSign);
  };
  var areaFilledWidth = Math.max(isCellTypeBattery ? widthPerCell * noOfVisibleCells - interCellsGap / 2 : width * valueRatio, 0);
  return import_react.default.createElement("g", null, import_react.default.createElement("defs", null, import_react.default.createElement("clipPath", {
    id: CLIP_METER_FILLED + clipPathHash
  }, import_react.default.createElement("rect", {
    x,
    y,
    width: areaFilledWidth,
    height,
    clipPath: "url(#" + (CLIP_METER + clipPathHash) + ")"
  })), import_react.default.createElement("clipPath", {
    id: CLIP_METER_EMPTY + clipPathHash
  }, import_react.default.createElement("rect", {
    x: x + areaFilledWidth,
    y,
    width: isCellTypeBattery ? widthPerCell * noOfInvisibleCells : width * (1 - valueRatio),
    height,
    clipPath: "url(#" + (CLIP_METER + clipPathHash) + ")"
  }))), renderTextElement(darkContrastColor, CLIP_METER_FILLED + clipPathHash), renderTextElement(lightContrastColor, CLIP_METER_EMPTY + clipPathHash));
};
var MAX_ANIMATION_PROGRESS = 1;
var MAX_LOOP_ANIMATION_PROGRESS = 2;
var useCounterAnimation = function useCounterAnimation2(_ref) {
  var value = _ref.value, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 1e3 : _ref$duration, _ref$startValue = _ref.startValue, startValue = _ref$startValue === void 0 ? 0 : _ref$startValue, _ref$enabled = _ref.enabled, enabled = _ref$enabled === void 0 ? false : _ref$enabled, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? "forward" : _ref$direction, _ref$iterationCount = _ref.iterationCount, iterationCount = _ref$iterationCount === void 0 ? 1 : _ref$iterationCount, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? "linear" : _ref$easing;
  var _useState = (0, import_react.useState)(startValue), counterValue = _useState[0], setCounterValue = _useState[1];
  var iteration = (0, import_react.useRef)(0);
  var runAnimation = (0, import_react.useCallback)(function() {
    iteration.current += 1;
    return new Promise(function(resolve) {
      var startTime = 0;
      var nextIterationDurationGap = duration / 5;
      var step = function step2(currentTime) {
        if (!startTime) {
          startTime = currentTime;
        }
        var progress = timing(Math.min((currentTime - startTime) / duration, direction === "both" ? MAX_LOOP_ANIMATION_PROGRESS : MAX_ANIMATION_PROGRESS), easing);
        function getNewValue(animationDir) {
          if (animationDir === "reverse") {
            return (1 - progress) * (value - counterValue) + counterValue;
          } else if (progress > 1 && animationDir === "both") {
            return (MAX_LOOP_ANIMATION_PROGRESS - progress) * (value - counterValue) + counterValue;
          } else {
            return progress * (value - counterValue) + counterValue;
          }
        }
        var newValue = getNewValue(direction);
        setCounterValue(Math.floor(newValue));
        if (progress < MAX_ANIMATION_PROGRESS || direction === "both" && progress < MAX_LOOP_ANIMATION_PROGRESS) {
          window.requestAnimationFrame(step2);
        } else {
          window.cancelAnimationFrame(window.requestAnimationFrame(step2));
          resolve(true);
        }
      };
      function runFirstIteration() {
        window.requestAnimationFrame(step);
      }
      function runNextIteration() {
        setTimeout(function() {
          window.requestAnimationFrame(step);
        }, nextIterationDurationGap);
      }
      (function startAnimation() {
        iteration.current > 1 ? runNextIteration() : runFirstIteration();
      })();
    });
  }, [value]);
  (0, import_react.useEffect)(function() {
    if (enabled) {
      var animation = runAnimation();
      var restartAnimation = function restartAnimation2() {
        animation.then(function() {
          if (iterationCount === "infinite") {
            animation = runAnimation();
            restartAnimation2();
            return;
          }
          if (iteration.current < iterationCount) {
            animation = runAnimation();
            restartAnimation2();
            return;
          }
        });
      };
      restartAnimation();
    }
  }, [enabled, iterationCount, value]);
  return enabled ? counterValue : value;
};
function useClipPathHash() {
  var _useState = (0, import_react.useState)(""), hash = _useState[0], setHash = _useState[1];
  (0, import_react.useEffect)(function() {
    setHash((Math.random() + 1).toString(36).substring(7));
  }, []);
  return hash;
}
var iconWidth = 16.8;
var iconHeight = 28.7;
function Charging(pathProps) {
  var _useGaugeContext = useGaugeContext(), canvasWidth = _useGaugeContext.canvasWidth, canvasHeight = _useGaugeContext.canvasHeight, orientation = _useGaugeContext.orientation, customization = _useGaugeContext.customization;
  var strokeWidth = customization[BATTERY_BODY].strokeWidth;
  var _customization$CHARGI = customization[CHARGING_FLASH], fill = _customization$CHARGI.fill, scale = _customization$CHARGI.scale, animated = _customization$CHARGI.animated, animationDuration = _customization$CHARGI.animationDuration;
  var animatedOpacityPer = useCounterAnimation({
    value: 100,
    enabled: animated,
    direction: "both",
    iterationCount: "infinite",
    duration: animationDuration,
    startValue: 20
  });
  var _useLevelDimensions = useLevelDimensions(), width = _useLevelDimensions.width;
  var iconXPos = width / 2 + iconWidth / 2;
  var iconYPos = canvasHeight / 2 - iconHeight / 2;
  var transformScale = scale ? "scale(" + scale + ")" : "";
  return import_react.default.createElement("g", {
    transform: orientation === "vertical" ? "rotate(-90)" + transformScale : transformScale,
    style: {
      transformOrigin: canvasWidth / 2 - strokeWidth + "px " + (canvasHeight / 2 - strokeWidth / 2) + "px"
    },
    opacity: animatedOpacityPer / 100
  }, import_react.default.createElement("path", Object.assign({
    d: "M" + iconXPos + "," + iconYPos + "l-13,16.8l7.4,0l-1.8,11.9l11.2,-16.8l-7.4,0l3.6,-11.9z",
    fill
  }, pathProps)));
}
var _excluded$2 = ["size", "aspectRatio", "children", "padding", "value", "chargingStartValue", "maxValue", "customization", "orientation", "animated", "charging", "formatValue"];
var BatteryGauge = function BatteryGauge2(_ref) {
  var _customization$BATTER, _allCustomization;
  var _ref$size = _ref.size, size = _ref$size === void 0 ? 300 : _ref$size, _ref$aspectRatio = _ref.aspectRatio, aspectRatio = _ref$aspectRatio === void 0 ? defaultState.aspectRatio : _ref$aspectRatio, children = _ref.children, _ref$padding = _ref.padding, padding = _ref$padding === void 0 ? defaultState.padding : _ref$padding, _ref$value = _ref.value, value = _ref$value === void 0 ? defaultState.value : _ref$value, _ref$chargingStartVal = _ref.chargingStartValue, chargingStartValue = _ref$chargingStartVal === void 0 ? defaultState.chargingStartValue : _ref$chargingStartVal, _ref$maxValue = _ref.maxValue, maxValue = _ref$maxValue === void 0 ? defaultState.maxValue : _ref$maxValue, _ref$customization = _ref.customization, customization = _ref$customization === void 0 ? defaultState.customization : _ref$customization, _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? defaultState.orientation : _ref$orientation, _ref$animated = _ref.animated, animated = _ref$animated === void 0 ? defaultState.animated : _ref$animated, _ref$charging = _ref.charging, charging = _ref$charging === void 0 ? defaultState.charging : _ref$charging, _ref$formatValue = _ref.formatValue, formatValue = _ref$formatValue === void 0 ? function(value2) {
    return value2;
  } : _ref$formatValue, restSvgProps = _objectWithoutPropertiesLoose(_ref, _excluded$2);
  var canvasHeight = Math.round(CANVAS_WIDTH * aspectRatio);
  var height = Math.round(size * aspectRatio);
  var clipPathHash = useClipPathHash();
  var noLowBatteryColor = charging ? {
    lowBatteryFill: ((_customization$BATTER = customization[BATTERY_METER]) == null ? void 0 : _customization$BATTER.fill) || defaultState.customization[BATTERY_METER].fill
  } : {};
  var allCustomization = (_allCustomization = {}, _allCustomization[BATTERY_BODY] = _extends({}, defaultState.customization[BATTERY_BODY], customization[BATTERY_BODY]), _allCustomization[BATTERY_CAP] = _extends({}, defaultState.customization[BATTERY_CAP], customization[BATTERY_CAP]), _allCustomization[BATTERY_METER] = _extends({}, defaultState.customization[BATTERY_METER], customization[BATTERY_METER], noLowBatteryColor), _allCustomization[READING_TEXT] = _extends({}, defaultState.customization[READING_TEXT], customization[READING_TEXT]), _allCustomization[CHARGING_FLASH] = _extends({}, defaultState.customization[CHARGING_FLASH], customization[CHARGING_FLASH]), _allCustomization);
  var canvasPadding = allCustomization.batteryBody.strokeWidth / 2 + padding;
  var newValue = useCounterAnimation({
    value,
    enabled: animated
  });
  var chargingValue = useCounterAnimation({
    startValue: chargingStartValue,
    value: maxValue,
    enabled: charging,
    iterationCount: "infinite",
    duration: 2e3
  });
  return import_react.default.createElement(Canvas, Object.assign({
    width: size,
    height: orientation === "vertical" ? size : height,
    canvasWidth: CANVAS_WIDTH,
    canvasHeight,
    padding: canvasPadding,
    value: charging ? chargingValue : newValue,
    chargingStartValue,
    maxValue: !maxValue ? 1 : maxValue,
    orientation,
    customization: allCustomization,
    clipPathHash
  }, restSvgProps), import_react.default.createElement("g", {
    transform: orientation === "vertical" ? "rotate(-90," + CANVAS_WIDTH / 2 + "," + canvasHeight / 2 + ")" : ""
  }, import_react.default.createElement(Battery, null), import_react.default.createElement(BatteryLevel, null), charging ? import_react.default.createElement(Charging, null) : import_react.default.createElement(ReadingText, {
    formatValue
  }), children));
};
var react_battery_gauge_esm_default = BatteryGauge;
export {
  BatteryGauge,
  react_battery_gauge_esm_default as default
};
//# sourceMappingURL=react-battery-gauge.js.map
