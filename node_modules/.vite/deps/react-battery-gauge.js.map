{
  "version": 3,
  "sources": ["../../react-battery-gauge/src/lib/constants/index.ts", "../../react-battery-gauge/src/lib/store/context.ts", "../../react-battery-gauge/src/lib/hooks/useGaugeContext.ts", "../../react-battery-gauge/src/lib/hooks/useBatteryDimensions.ts", "../../react-battery-gauge/src/lib/components/Battery/index.tsx", "../../react-battery-gauge/src/lib/store/Provider.tsx", "../../react-battery-gauge/src/lib/Canvas.tsx", "../../react-battery-gauge/src/lib/hooks/useLevelDimensions.ts", "../../react-battery-gauge/src/lib/utils/index.ts", "../../react-battery-gauge/src/lib/components/BatteryLevel.tsx", "../../react-battery-gauge/src/lib/components/ReadingText.tsx", "../../react-battery-gauge/src/lib/hooks/useCounterAnimation.ts", "../../react-battery-gauge/src/lib/hooks/useClipPathHash.ts", "../../react-battery-gauge/src/lib/components/Charging.tsx", "../../react-battery-gauge/src/index.tsx"],
  "sourcesContent": ["export const CANVAS_WIDTH = 100;\nconst CANVAS_HEIGHT = 52;\n\nexport const BATTERY_ASPECT_RATIO = CANVAS_HEIGHT / CANVAS_WIDTH; // battery is horizontal\nexport const BATTERY_BODY = 'batteryBody';\nexport const BATTERY_CAP = 'batteryCap';\nexport const BATTERY_METER = 'batteryMeter';\nexport const READING_TEXT = 'readingText';\nexport const CHARGING_FLASH = 'chargingFlash';\n\n// clipPath ids\nexport const CLIP_METER = 'clip_level_meter';\nexport const CLIP_METER_FILLED = 'clip_level_meter_filled';\nexport const CLIP_METER_EMPTY = 'clip_level_meter_empty';\nexport const CLIP_CAP = 'battery_cap_clip';\n", "import { BATTERY_ASPECT_RATIO, CANVAS_WIDTH } from './../constants/index';\nimport { createContext } from 'react';\nimport type { TGaugeCanvas } from '../../typings';\n\nexport const defaultState = {\n  canvasWidth: CANVAS_WIDTH,\n  canvasHeight: CANVAS_WIDTH * BATTERY_ASPECT_RATIO,\n  aspectRatio: BATTERY_ASPECT_RATIO,\n  padding: 0,\n  value: 50,\n  chargingStartValue: 1,\n  maxValue: 100,\n  clipPathHash: '',\n  orientation: 'horizontal' as TGaugeCanvas['orientation'],\n  animated: false,\n  charging: false,\n  customization: {\n    batteryBody: {\n      strokeWidth: 4,\n      cornerRadius: 6,\n      fill: 'none',\n      strokeColor: '#111',\n    },\n    batteryCap: {\n      fill: 'none',\n      strokeWidth: 4,\n      strokeColor: '#111',\n      cornerRadius: 2,\n      capToBodyRatio: 0.4,\n    },\n    batteryMeter: {\n      fill: 'green',\n      lowBatteryValue: 15,\n      lowBatteryFill: 'red',\n      outerGap: 1,\n      noOfCells: 1,\n      interCellsGap: 1,\n    },\n    readingText: {\n      lightContrastColor: '#111',\n      darkContrastColor: '#fff',\n      lowBatteryColor: 'red',\n      fontFamily: 'Helvetica',\n      fontSize: 14,\n      showPercentage: true,\n    },\n    chargingFlash: {\n      scale: undefined,\n      fill: 'orange',\n      animated: true,\n      animationDuration: 1000,\n    },\n  },\n};\n\nexport const Context = createContext<TGaugeCanvas>(defaultState);\n", "import { ContextType, useContext } from 'react';\nimport { Context } from '../store/context';\n\nexport function useGaugeContext() {\n  return useContext(Context);\n}\n\nexport type UseGaugeContextReturnValue = ContextType<typeof Context>;\n", "import { useGaugeContext } from './useGaugeContext';\n\nexport const useBatteryDimensions = (batteryCapRatio: number) => {\n  const { canvasHeight, canvasWidth, padding } = useGaugeContext();\n  const objectHeight = canvasHeight - 2 * padding; // total canvas height minus vertical padding\n  const capHeight = objectHeight * batteryCapRatio;\n  const capWidth = capHeight / 2;\n\n  return {\n    bodyWidth: canvasWidth - capWidth - 2 * padding,\n    bodyHeight: canvasHeight - 2 * padding,\n    capWidth,\n    capHeight,\n  };\n};\n", "import React from 'react';\nimport { BATTERY_BODY, BATTERY_CAP, CLIP_CAP } from '../../constants';\nimport { useBatteryDimensions } from '../../hooks/useBatteryDimensions';\nimport { useGaugeContext } from '../../hooks/useGaugeContext';\n\nexport const Battery = () => {\n  const { canvasWidth, canvasHeight, padding, customization, clipPathHash } =\n    useGaugeContext();\n\n  const {\n    strokeColor: bodyStrokeColor,\n    strokeWidth: bodyStrokeWidth,\n    fill: bodyFill,\n    cornerRadius: bodyCornerRadius,\n  } = customization[BATTERY_BODY];\n\n  const {\n    strokeColor: capStrokeColor,\n    strokeWidth: capStrokeWidth,\n    fill: capFill,\n    cornerRadius: capCornerRadius,\n    capToBodyRatio,\n  } = customization[BATTERY_CAP];\n\n  const { bodyWidth, bodyHeight, capWidth, capHeight } =\n    useBatteryDimensions(capToBodyRatio);\n  return (\n    <g>\n      <defs>\n        <clipPath id={CLIP_CAP + clipPathHash}>\n          <rect\n            x={canvasWidth - padding - capWidth}\n            y={(canvasHeight - capHeight - capStrokeWidth) / 2}\n            width={capWidth}\n            height={capHeight + capStrokeWidth}\n            strokeWidth={capStrokeWidth}\n          />\n        </clipPath>\n      </defs>\n      <rect\n        className={BATTERY_BODY}\n        x={padding}\n        y={padding}\n        rx={bodyCornerRadius}\n        ry={bodyCornerRadius}\n        width={bodyWidth}\n        height={bodyHeight}\n        strokeWidth={bodyStrokeWidth}\n        fill={bodyFill}\n        stroke={bodyStrokeColor}\n      />\n      <rect\n        clipPath={`url(#${CLIP_CAP + clipPathHash})`}\n        className={BATTERY_CAP}\n        x={canvasWidth - padding - capWidth - capCornerRadius}\n        y={(canvasHeight - capHeight) / 2}\n        rx={capCornerRadius}\n        ry={capCornerRadius}\n        width={capWidth}\n        height={capHeight}\n        strokeWidth={capStrokeWidth}\n        fill={capFill}\n        stroke={capStrokeColor}\n      />\n    </g>\n  );\n};\n", "import React, { FC } from 'react';\nimport type { TGaugeCanvas } from '../../typings';\nimport { Context } from './context';\n\ninterface Props {\n  value: TGaugeCanvas & { clipPathHash: string };\n}\n\nexport const CanvasProvider: FC<Props> = ({ children, value }) => {\n  return <Context.Provider value={value}>{children}</Context.Provider>;\n};\n", "import React from 'react';\nimport { TGaugeCanvas } from '../typings';\nimport { CanvasProvider } from './store/Provider';\n\nexport interface TCanvasProps\n  extends Omit<React.SVGProps<SVGSVGElement>, 'orientation'>,\n    TGaugeCanvas {}\n\nexport const Canvas = (props: TCanvasProps) => {\n  const {\n    children,\n    canvasWidth,\n    canvasHeight,\n    padding,\n    value,\n    chargingStartValue,\n    maxValue,\n    orientation,\n    customization,\n    clipPathHash,\n    ...otherSvgProps\n  } = props;\n  return (\n    <CanvasProvider\n      value={{\n        canvasWidth,\n        canvasHeight,\n        padding,\n        value,\n        chargingStartValue,\n        maxValue,\n        orientation,\n        customization,\n        clipPathHash,\n      }}\n    >\n      <svg viewBox={`0 0 ${canvasWidth} ${canvasHeight}`} {...otherSvgProps}>\n        {children}\n      </svg>\n    </CanvasProvider>\n  );\n};\n", "import { BATTERY_CAP, BATTERY_METER, BATTERY_BODY } from './../constants/index';\nimport { useMemo } from 'react';\nimport { useBatteryDimensions } from './useBatteryDimensions';\nimport { useGaugeContext } from './useGaugeContext';\n\nexport const useLevelDimensions = () => {\n  const { padding, customization } = useGaugeContext();\n  const { strokeWidth } = customization[BATTERY_BODY];\n  const { capToBodyRatio } = customization[BATTERY_CAP];\n  const { outerGap } = customization[BATTERY_METER];\n  const { bodyWidth, bodyHeight } = useBatteryDimensions(capToBodyRatio);\n\n  return useMemo(() => {\n    const innerBodyWidth = bodyWidth - strokeWidth;\n    const innerBodyHeight = bodyHeight - strokeWidth;\n    return {\n      x: padding + strokeWidth / 2 + outerGap,\n      y: padding + strokeWidth / 2 + outerGap,\n      width: innerBodyWidth - 2 * outerGap,\n      height: innerBodyHeight - 2 * outerGap,\n    };\n  }, [bodyWidth, bodyHeight, outerGap, padding, strokeWidth]);\n};\n", "export function getValueInPercentage(value: number, maxValue: number) {\n  return Math.round((value / maxValue) * 100);\n}\n\nexport function checkLowBattery(value: number, lowBatteryValue: number) {\n  return value < lowBatteryValue;\n}\n\nexport function getVisibleCellsCount(\n  value: number,\n  maxValue: number,\n  noOfCells: number\n) {\n  return Math.floor(Math.abs(value / maxValue) * noOfCells);\n}\nexport const timing = (progress: number, easing?: 'linear') => {\n  if (easing === 'linear') {\n    return progress;\n  }\n  return progress;\n};\n", "import React, { useMemo } from 'react';\nimport {\n  BATTERY_BODY,\n  BATTERY_METER,\n  CLIP_METER,\n  CLIP_METER_FILLED,\n} from '../constants';\nimport { useGaugeContext } from '../hooks/useGaugeContext';\nimport { useLevelDimensions } from '../hooks/useLevelDimensions';\nimport { checkLowBattery, getVisibleCellsCount } from '../utils';\n\nexport const BatteryLevel = () => {\n  const { value, maxValue, customization, clipPathHash } = useGaugeContext();\n  const { x, y, width, height } = useLevelDimensions();\n  const {\n    fill,\n    lowBatteryFill,\n    gradFill,\n    lowBatteryValue,\n    outerGap,\n    noOfCells,\n    interCellsGap,\n  } = customization[BATTERY_METER];\n  const { strokeWidth: bodyStrokeWidth, cornerRadius: bodyCornerRadius } =\n    customization[BATTERY_BODY];\n\n  const cellList = useMemo(() => {\n    const noOfVisibleCells = getVisibleCellsCount(value, maxValue, noOfCells);\n    if (noOfVisibleCells === 0 && value > 0) {\n      return ['cell'];\n    }\n    return new Array(noOfVisibleCells).fill('cell');\n  }, [value, maxValue, noOfCells]);\n\n  return (\n    <g>\n      <defs>\n        <clipPath id={CLIP_METER + clipPathHash}>\n          <rect\n            x={x}\n            y={y}\n            rx={bodyCornerRadius - bodyStrokeWidth / 2 - outerGap}\n            ry={bodyCornerRadius - bodyStrokeWidth / 2 - outerGap}\n            width={width}\n            height={height}\n          />\n        </clipPath>\n        {noOfCells < 2 && gradFill && (\n          <linearGradient id={'levelGradient' + clipPathHash}>\n            {gradFill.map((item) => {\n              return (\n                <stop\n                  key={item.color}\n                  offset={item.offset + '%'}\n                  stopColor={item.color}\n                />\n              );\n            })}\n          </linearGradient>\n        )}\n      </defs>\n      {noOfCells === 1 && (\n        <g>\n          {gradFill ? (\n            <rect\n              className={BATTERY_METER}\n              clipPath={`url(#${CLIP_METER_FILLED + clipPathHash})`}\n              x={x}\n              y={y}\n              width={width}\n              height={height}\n              fill={`url(#levelGradient${clipPathHash})`}\n            />\n          ) : (\n            <rect\n              className={BATTERY_METER}\n              clipPath={`url(#${CLIP_METER + clipPathHash})`}\n              x={x}\n              y={y}\n              width={(width * value) / maxValue}\n              height={height}\n              fill={\n                checkLowBattery(value, lowBatteryValue) ? lowBatteryFill : fill\n              }\n            />\n          )}\n        </g>\n      )}\n      <g>\n        {noOfCells > 1 &&\n          cellList.map((_item, index) => {\n            return (\n              <rect\n                key={index}\n                className={BATTERY_METER}\n                clipPath={`url(#${CLIP_METER + clipPathHash})`}\n                x={x + ((width + interCellsGap) / noOfCells) * index}\n                y={y}\n                width={width / noOfCells - interCellsGap}\n                height={height}\n                fill={\n                  checkLowBattery(value, lowBatteryValue)\n                    ? lowBatteryFill\n                    : fill\n                }\n              />\n            );\n          })}\n      </g>\n    </g>\n  );\n};\n", "import React from 'react';\nimport {\n  BATTERY_METER,\n  CLIP_METER,\n  CLIP_METER_EMPTY,\n  CLIP_METER_FILLED,\n  READING_TEXT,\n} from '../constants';\nimport { useGaugeContext } from '../hooks/useGaugeContext';\nimport { useLevelDimensions } from '../hooks/useLevelDimensions';\nimport {\n  checkLowBattery,\n  getValueInPercentage,\n  getVisibleCellsCount,\n} from '../utils';\nimport type { FormatValue } from '../../typings';\n\ntype ReadingTextProps = {\n  formatValue: FormatValue;\n};\nexport const ReadingText = (props: ReadingTextProps) => {\n  const { formatValue } = props;\n  const { value, maxValue, orientation, customization, clipPathHash } =\n    useGaugeContext();\n  const { x, y, width, height } = useLevelDimensions();\n  const {\n    fontFamily,\n    darkContrastColor,\n    lightContrastColor,\n    lowBatteryColor,\n    showPercentage,\n    fontSize,\n    ...otherTextProps\n  } = customization[READING_TEXT];\n  const { lowBatteryValue, noOfCells, interCellsGap } =\n    customization[BATTERY_METER];\n  const percentageSign = showPercentage ? '%' : '';\n  const valueRatio = value / maxValue;\n  const isCellTypeBattery = noOfCells > 1;\n  const noOfVisibleCells = getVisibleCellsCount(value, maxValue, noOfCells);\n  const noOfInvisibleCells = noOfCells - noOfVisibleCells;\n  const widthPerCell = width / noOfCells;\n  const readingValue = getValueInPercentage(value, maxValue);\n\n  const renderTextElement = (contrastColor: string, clipPathId: string) => {\n    return (\n      <text\n        className={READING_TEXT}\n        x={x + width / 2}\n        y={y + height / 2}\n        dominantBaseline=\"middle\"\n        textAnchor=\"middle\"\n        clipPath={`url(#${clipPathId})`}\n        fill={\n          checkLowBattery(value, lowBatteryValue)\n            ? lowBatteryColor\n            : contrastColor\n        }\n        fontFamily={fontFamily}\n        fontWeight=\"bold\"\n        fontSize={fontSize}\n        writingMode={orientation === 'vertical' ? 'tb' : 'lr'}\n        {...otherTextProps}\n      >\n        {formatValue(readingValue) + percentageSign}\n      </text>\n    );\n  };\n  const areaFilledWidth = Math.max(\n    isCellTypeBattery\n      ? widthPerCell * noOfVisibleCells - interCellsGap / 2\n      : width * valueRatio,\n    0\n  );\n\n  return (\n    <g>\n      <defs>\n        <clipPath id={CLIP_METER_FILLED + clipPathHash}>\n          <rect\n            x={x}\n            y={y}\n            width={areaFilledWidth}\n            height={height}\n            clipPath={`url(#${CLIP_METER + clipPathHash})`}\n          />\n        </clipPath>\n        <clipPath id={CLIP_METER_EMPTY + clipPathHash}>\n          <rect\n            x={x + areaFilledWidth}\n            y={y}\n            width={\n              isCellTypeBattery\n                ? widthPerCell * noOfInvisibleCells\n                : width * (1 - valueRatio)\n            }\n            height={height}\n            clipPath={`url(#${CLIP_METER + clipPathHash})`}\n          />\n        </clipPath>\n      </defs>\n      {renderTextElement(darkContrastColor, CLIP_METER_FILLED + clipPathHash)}\n      {renderTextElement(lightContrastColor, CLIP_METER_EMPTY + clipPathHash)}\n    </g>\n  );\n};\n", "import { useEffect, useState, useCallback, useRef } from 'react';\nimport { timing } from '../utils';\n\nexport type AnimationType = {\n  value: number;\n  duration?: number;\n  startValue?: number;\n  enabled: boolean;\n  direction?: 'both' | 'reverse' | 'forward';\n  iterationCount?: number | 'infinite';\n  easing?: 'linear';\n};\n\nconst MAX_ANIMATION_PROGRESS = 1;\nconst MAX_LOOP_ANIMATION_PROGRESS = 2;\n\nexport const useCounterAnimation = ({\n  value,\n  duration = 1000,\n  startValue = 0,\n  enabled = false,\n  direction = 'forward',\n  iterationCount = 1,\n  easing = 'linear',\n}: AnimationType) => {\n  const [counterValue, setCounterValue] = useState(startValue);\n  const iteration = useRef(0);\n\n  const runAnimation = useCallback(() => {\n    iteration.current += 1;\n\n    return new Promise((resolve) => {\n      let startTime = 0;\n      const nextIterationDurationGap = duration / 5;\n      const step = (currentTime: number) => {\n        if (!startTime) {\n          startTime = currentTime;\n        }\n\n        //calculate the value to be used in calculating the number to be displayed\n        const progress = timing(\n          Math.min(\n            (currentTime - startTime) / duration,\n            direction === 'both'\n              ? MAX_LOOP_ANIMATION_PROGRESS\n              : MAX_ANIMATION_PROGRESS\n          ),\n          easing\n        );\n        function getNewValue(animationDir: AnimationType['direction']) {\n          if (animationDir === 'reverse') {\n            return (1 - progress) * (value - counterValue) + counterValue;\n          } else if (progress > 1 && animationDir === 'both') {\n            return (\n              (MAX_LOOP_ANIMATION_PROGRESS - progress) *\n                (value - counterValue) +\n              counterValue\n            );\n          } else {\n            return progress * (value - counterValue) + counterValue;\n          }\n        }\n        const newValue = getNewValue(direction);\n\n        //calculate what to be displayed using the value gotten above\n        setCounterValue(Math.floor(newValue));\n\n        if (\n          progress < MAX_ANIMATION_PROGRESS ||\n          (direction === 'both' && progress < MAX_LOOP_ANIMATION_PROGRESS)\n        ) {\n          window.requestAnimationFrame(step); //continue animation\n        } else {\n          window.cancelAnimationFrame(window.requestAnimationFrame(step));\n          resolve(true); //complete animation\n        }\n      };\n\n      // First loop of animation, take no delay\n      function runFirstIteration() {\n        window.requestAnimationFrame(step);\n      }\n\n      // For second loop for animation, take some pause before starting\n      function runNextIteration() {\n        setTimeout(() => {\n          window.requestAnimationFrame(step);\n        }, nextIterationDurationGap);\n      }\n      // start animation\n      (function startAnimation() {\n        iteration.current > 1 ? runNextIteration() : runFirstIteration();\n      })();\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [value]);\n\n  useEffect(() => {\n    if (enabled) {\n      let animation = runAnimation();\n      const restartAnimation = () => {\n        animation.then(() => {\n          if (iterationCount === 'infinite') {\n            animation = runAnimation();\n            restartAnimation();\n            return;\n          }\n          if (iteration.current < iterationCount) {\n            animation = runAnimation();\n            restartAnimation();\n            return;\n          }\n        });\n      };\n      restartAnimation();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [enabled, iterationCount, value]);\n\n  return enabled ? counterValue : value;\n};\n", "import { useEffect, useState } from 'react';\n\nexport function useClipPathHash() {\n  const [hash, setHash] = useState<string>('');\n  useEffect(() => {\n    setHash((Math.random() + 1).toString(36).substring(7));\n  }, []);\n  return hash;\n}\n", "import React, { ReactElement } from 'react';\nimport { BATTERY_BODY, CHARGING_FLASH } from '../constants';\nimport { useCounterAnimation } from '../hooks/useCounterAnimation';\nimport { useGaugeContext } from '../hooks/useGaugeContext';\nimport { useLevelDimensions } from '../hooks/useLevelDimensions';\n\ntype Props = Omit<React.SVGProps<SVGPathElement>, \"scale\">\n\n// As per icon path\nconst iconWidth = 16.8; // As per path\nconst iconHeight = 28.7;\n\nexport default function Charging(pathProps: Props): ReactElement {\n  const { canvasWidth, canvasHeight, orientation, customization } =\n    useGaugeContext();\n  const { strokeWidth } = customization[BATTERY_BODY];\n  const { fill, scale, animated, animationDuration } = customization[CHARGING_FLASH];\n  const animatedOpacityPer = useCounterAnimation({\n    value: 100,\n    enabled: animated,\n    direction: 'both',\n    iterationCount: 'infinite',\n    duration: animationDuration,\n    startValue: 20,\n  });\n\n  const { width } = useLevelDimensions();\n  const iconXPos = width / 2 + iconWidth / 2;\n  const iconYPos = canvasHeight / 2 - iconHeight / 2;\n  const transformScale = scale ? `scale(${scale})` : '';\n  return (\n    <g\n      transform={\n        orientation === 'vertical'\n          ? `rotate(${-90})${transformScale}`\n          : transformScale\n      }\n      style={{\n        transformOrigin: `${canvasWidth / 2 - strokeWidth}px ${\n          canvasHeight / 2 - strokeWidth / 2\n        }px`,\n      }}\n      opacity={animatedOpacityPer / 100}\n    >\n      <path\n        d={`M${iconXPos},${iconYPos}l-13,16.8l7.4,0l-1.8,11.9l11.2,-16.8l-7.4,0l3.6,-11.9z`}\n        fill={fill}\n        {...pathProps}\n      />\n    </g>\n  );\n}\n", "import React, { FC } from 'react';\nimport {\n  BATTERY_BODY,\n  BATTERY_CAP,\n  BATTERY_METER,\n  CANVAS_WIDTH,\n  CHARGING_FLASH,\n  READING_TEXT,\n} from './lib/constants';\nimport { Battery } from './lib/components/Battery';\nimport { Canvas } from './lib/Canvas';\nimport { BatteryLevel } from './lib/components/BatteryLevel';\nimport type {\n  DeepPartial,\n  FormatValue,\n  TGaugeCanvas,\n  TGaugeCustom,\n} from './typings';\nimport { defaultState } from './lib/store/context';\nimport { ReadingText } from './lib/components/ReadingText';\nimport { useCounterAnimation } from './lib/hooks/useCounterAnimation';\nimport { useClipPathHash } from './lib/hooks/useClipPathHash';\nimport Charging from './lib/components/Charging';\n\nexport interface Props\n  extends Omit<React.SVGProps<SVGSVGElement>, 'orientation'> {\n  /**\n   * Meter value range [0-100]\n   */\n  value: TGaugeCanvas['value'];\n  /**\n   * Meter max value\n   */\n  maxValue?: TGaugeCanvas['maxValue'];\n  /**\n   * Charging starting value\n   */\n  chargingStartValue?: TGaugeCanvas['chargingStartValue'];\n  /**\n   * Changes orientation, keeping text horizontal\n   */\n  orientation?: TGaugeCanvas['orientation'];\n\n  /**\n   * We don't like passing both width and height, can create unusual looking shape.\n   * Size will help gauge to achieve the desired size maintaining aspect ratio\n   */\n  size?: number;\n  /**\n   * Gauge aspect ratio,\n   * At padding 0 easy to create battery types ->\n   * D = 0.56,\n   * C = 0.52,\n   * AA = 0.28,\n   * AAA = 0.23,\n   * AAAA = 0.19 ,\n   * default C battery\n   */\n  aspectRatio?: number;\n  /**\n   * Padding of gauge within canvas\n   */\n  padding?: TGaugeCanvas['padding'];\n  /**\n   * Enable animation on mount\n   */\n  animated?: boolean;\n  /**\n   * Battery is charging\n   */\n  charging?: boolean;\n  /**\n   * Format the visible reading text as per your need\n   * Note: you can turn off percentage symbol from customizations\n   */\n  formatValue?: FormatValue;\n  /**\n   * All components customization\n   */\n  customization?: DeepPartial<TGaugeCustom>;\n}\n\nexport const BatteryGauge: FC<Props> = ({\n  size = 300,\n  aspectRatio = defaultState.aspectRatio,\n  children,\n  padding = defaultState.padding,\n  value = defaultState.value,\n  chargingStartValue = defaultState.chargingStartValue,\n  maxValue = defaultState.maxValue,\n  customization = defaultState.customization,\n  orientation = defaultState.orientation,\n  animated = defaultState.animated,\n  charging = defaultState.charging,\n  formatValue = (value) => value,\n  ...restSvgProps\n}) => {\n  const canvasHeight = Math.round(CANVAS_WIDTH * aspectRatio);\n  const height = Math.round(size * aspectRatio);\n  const clipPathHash = useClipPathHash();\n  const noLowBatteryColor = charging\n    ? {\n        lowBatteryFill:\n          customization[BATTERY_METER]?.fill ||\n          defaultState.customization[BATTERY_METER].fill,\n      }\n    : {};\n\n  const allCustomization: TGaugeCustom = {\n    [BATTERY_BODY]: {\n      ...defaultState.customization[BATTERY_BODY],\n      ...customization[BATTERY_BODY],\n    },\n    [BATTERY_CAP]: {\n      ...defaultState.customization[BATTERY_CAP],\n      ...customization[BATTERY_CAP],\n    },\n    [BATTERY_METER]: {\n      ...defaultState.customization[BATTERY_METER],\n      ...customization[BATTERY_METER],\n      ...noLowBatteryColor,\n    },\n    [READING_TEXT]: {\n      ...defaultState.customization[READING_TEXT],\n      ...customization[READING_TEXT],\n    },\n    [CHARGING_FLASH]: {\n      ...defaultState.customization[CHARGING_FLASH],\n      ...customization[CHARGING_FLASH],\n    },\n  };\n  const canvasPadding = allCustomization.batteryBody.strokeWidth / 2 + padding;\n  const newValue = useCounterAnimation({\n    value: value,\n    enabled: animated,\n  });\n  const chargingValue = useCounterAnimation({\n    startValue: chargingStartValue,\n    value: maxValue,\n    enabled: charging,\n    iterationCount: 'infinite',\n    duration: 2000,\n  });\n  return (\n    <Canvas\n      width={size}\n      height={orientation === 'vertical' ? size : height}\n      canvasWidth={CANVAS_WIDTH}\n      canvasHeight={canvasHeight}\n      padding={canvasPadding}\n      value={charging ? chargingValue : newValue}\n      chargingStartValue={chargingStartValue}\n      maxValue={!maxValue ? 1 : maxValue}\n      orientation={orientation}\n      customization={allCustomization}\n      clipPathHash={clipPathHash}\n      {...restSvgProps}\n    >\n      <g\n        transform={\n          orientation === 'vertical'\n            ? `rotate(-90,${CANVAS_WIDTH / 2},${canvasHeight / 2})` // rotate at right top corner\n            : ''\n        }\n      >\n        <Battery />\n        <BatteryLevel />\n        {charging ? <Charging /> : <ReadingText formatValue={formatValue} />}\n        {children}\n      </g>\n    </Canvas>\n  );\n};\n\nexport default BatteryGauge;\n"],
  "mappings": "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",
  "names": ["CANVAS_WIDTH", "CANVAS_HEIGHT", "BATTERY_ASPECT_RATIO", "BATTERY_BODY", "BATTERY_CAP", "BATTERY_METER", "READING_TEXT", "CHARGING_FLASH", "CLIP_METER", "CLIP_METER_FILLED", "CLIP_METER_EMPTY", "CLIP_CAP", "defaultState", "canvasWidth", "canvasHeight", "aspectRatio", "padding", "value", "chargingStartValue", "maxValue", "clipPathHash", "orientation", "animated", "charging", "customization", "batteryBody", "strokeWidth", "cornerRadius", "fill", "strokeColor", "batteryCap", "capToBodyRatio", "batteryMeter", "lowBatteryValue", "lowBatteryFill", "outerGap", "noOfCells", "interCellsGap", "readingText", "lightContrastColor", "darkContrastColor", "lowBatteryColor", "fontFamily", "fontSize", "showPercentage", "chargingFlash", "scale", "undefined", "animationDuration", "Context", "createContext", "useGaugeContext", "useContext", "useBatteryDimensions", "batteryCapRatio", "_useGaugeContext", "objectHeight", "capHeight", "capWidth", "bodyWidth", "bodyHeight", "Battery", "_customization$BATTER", "bodyStrokeColor", "bodyStrokeWidth", "bodyFill", "bodyCornerRadius", "_customization$BATTER2", "capStrokeColor", "capStrokeWidth", "capFill", "capCornerRadius", "_useBatteryDimensions", "React", "id", "x", "y", "width", "height", "className", "rx", "ry", "stroke", "clipPath", "CanvasProvider", "_ref", "children", "Provider", "Canvas", "props", "otherSvgProps", "_objectWithoutPropertiesLoose", "_excluded", "viewBox", "useLevelDimensions", "useMemo", "innerBodyWidth", "innerBodyHeight", "getValueInPercentage", "Math", "round", "checkLowBattery", "getVisibleCellsCount", "floor", "abs", "timing", "progress", "easing", "BatteryLevel", "_useLevelDimensions", "gradFill", "cellList", "noOfVisibleCells", "Array", "map", "item", "key", "color", "offset", "stopColor", "_item", "index", "ReadingText", "formatValue", "_customization$READIN", "otherTextProps", "percentageSign", "valueRatio", "isCellTypeBattery", "noOfInvisibleCells", "widthPerCell", "readingValue", "renderTextElement", "contrastColor", "clipPathId", "dominantBaseline", "textAnchor", "fontWeight", "writingMode", "areaFilledWidth", "max", "MAX_ANIMATION_PROGRESS", "MAX_LOOP_ANIMATION_PROGRESS", "useCounterAnimation", "_ref$duration", "duration", "_ref$startValue", "startValue", "_ref$enabled", "enabled", "_ref$direction", "direction", "_ref$iterationCount", "iterationCount", "_ref$easing", "_useState", "useState", "counterValue", "setCounterValue", "iteration", "useRef", "runAnimation", "useCallback", "current", "Promise", "resolve", "startTime", "nextIterationDurationGap", "step", "currentTime", "min", "getNewValue", "animationDir", "newValue", "window", "requestAnimationFrame", "cancelAnimationFrame", "runFirstIteration", "runNextIteration", "setTimeout", "startAnimation", "useEffect", "animation", "restartAnimation", "then", "useClipPathHash", "hash", "setHash", "random", "toString", "substring", "iconWidth", "iconHeight", "Charging", "pathProps", "_customization$CHARGI", "animatedOpacityPer", "iconXPos", "iconYPos", "transformScale", "transform", "style", "transformOrigin", "opacity", "d", "BatteryGauge", "size", "_ref$size", "_ref$aspectRatio", "_ref$padding", "_ref$value", "_ref$chargingStartVal", "_ref$maxValue", "_ref$customization", "_ref$orientation", "_ref$animated", "_ref$charging", "_ref$formatValue", "restSvgProps", "noLowBatteryColor", "allCustomization", "_allCustomization", "_extends", "canvasPadding", "chargingValue"]
}
